<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Get Alternate Greetings</title>
    <script src="https://cdn.jsdelivr.net/combine/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js,npm/crc-32@1.2,gh/syonfox/GPT-3-Encoder@c3c2e2533a15645d812b5e6fcb00b75b74718161/browser.min.js"></script>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
      }

      #floating-window {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: #000;
        border: 4px solid #555;
        border-radius: 8px;
        color: #fff;
        padding: 10px;
        width: 400px;
        /* Increased width */
        max-height: 400px;
        overflow-y: auto;
        box-shadow: 0px 0px 10px 0px rgba(0, 0, 0, 0.2);
      }

      .select-button,
      #get-alternate-btn {
        background-color: #555;
        color: #fff;
        padding: 10px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        margin-top: 10px;
      }

      #get-alternate-btn {
        margin-left: 5px;
      }

      #fileForm {
        margin-bottom: 10px;
      }

      #alternateGreetings p {
        margin-bottom: 10px;
        padding: 10px;
        border: 2px solid #777;
        border-radius: 5px;
        position: relative;
      }

      #select-btn {
        position: absolute;
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
        padding: 5px;
        background-color: #555;
        color: #fff;
        border: none;
        cursor: pointer;
      }

      #floating-window-btn {
        position: fixed;
        top: 10px;
        /* Adjusted to the top */
        right: 10px;
        /* Moved to the right corner */
        padding: 10px;
        background-color: #555;
        color: #fff;
        border: none;
        cursor: pointer;
      }

      #cancel-btn {
        position: absolute;
        top: 20px;
        right: 10px;
        padding: 5px;
        background-color: #e74c3c;
        color: #fff;
        border: none;
        border-radius: 5px;
        cursor: pointer;
      }

      /* Style for the custom file input button */
      .custom-file-input {
        display: none;
        /* Hide the default file input */
      }

      .custom-file-label {
        background-color: #555;
        color: #fff;
        padding: 10px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        display: inline-block;
      }
    </style>
  </head>

  <body>
    <button id="floating-window-btn" onclick="toggleFloatingWindow()">
      Add Character
    </button>

    <div id="floating-window">
      <button id="cancel-btn" onclick="toggleFloatingWindow()">Cancel</button>
      <form
        id="fileForm"
        action="http://localhost:5000/get_alternate_greetings"
        method="POST"
        enctype="multipart/form-data"
      >
        <label for="file" class="custom-file-label">Choose File</label>
        <input
          type="file"
          id="file"
          name="file"
          accept=".json, .png"
          required
          class="custom-file-input"
          onchange="getAlternateGreetings()"
        />
      </form>

      <div id="alternateGreetings"></div>
    </div>

    <script>
      var displayAddCharacterButton = true; // You can change this value as needed
      let CharacterData = {};
      let Avatar = "";
      function updateAddCharacterButtonVisibility() {
        const addCharacterButton = document.getElementById(
          "floating-window-btn"
        );
        addCharacterButton.style.display = displayAddCharacterButton
          ? "block"
          : "none";
      }
      function getCookie(name) {
              var match = document.cookie.match(new RegExp('(^| )' + name + '=([^;]+)'));
              return match ? match[2] : null;
            }
      async function uploadToCatbox(imagePath) {
        const url = "https://catbox.moe/user/api.php";
        const formData = new FormData();
        formData.append(
          "fileToUpload",
          imagePath.name,
          await fetch(imagePath).then((response) => response.blob())
        );

        const data = {
          reqtype: "fileupload",
          userhash: getCookie("catBoxToken"),
        };

        const response = await fetch(url, {
          method: "POST",
          body: formData,
        });

        const catboxLink = await response.text();
        return catboxLink.trim();
      }
      async function getAlternateGreetings() {
        try {
          const fileInput = document.getElementById("file");
          const file = fileInput.files[0];

          // Check if the uploaded file is a JSON file
          if (file.type === "application/json") {
            Avatar = "";
            const reader = new FileReader();
            reader.onload = async function (event) {
              try {
                const characterData = JSON.parse(event.target.result);
                // Save the extracted character data
                CharacterData = characterData;
                displayGreetings(characterData);
              } catch (error) {
                console.error("Error parsing JSON file:", error);
                alert("Error parsing JSON file. Please try again.");
              }
            };
            reader.readAsText(file);
          } else if (file.type === "image/png") {
            // Check if the uploaded file is a PNG image
            // Extract character data from the image
            if (!getCookie("catBoxToken") === "") {
              Avatar = await uploadToCatbox(file);
            }
            else {
              Avatar = "";
            }
            const characterData = await extractCharacterData(file);
            // Save the extracted character data
            CharacterData = characterData;
            displayGreetings(characterData);
          } else {
            alert(
              "Unsupported file type. Please upload a PNG image or a JSON file."
            );
          }
        } catch (error) {
          console.error("Error:", error);
          alert("Error processing file. Please try again.");
        }
      }

      function displayGreetings(characterData) {
        const firstGreeting = characterData.data.first_mes;
        const alternateGreetings = characterData.data.alternate_greetings;
        const allGreetings = [firstGreeting, ...alternateGreetings];
        const greetingsElement = document.getElementById("alternateGreetings");
        greetingsElement.innerHTML = ""; // Clear previous greetings
        if (allGreetings && allGreetings.length > 0) {
          allGreetings.forEach((greeting, index) => {
            greetingsElement.innerHTML += `
        <div class="greeting-container">
          <div class="greeting-content">
              <p id="greeting-${index + 1}">${index + 1} - ${greeting.replace(
              /\n/g,
              "<br>"
            )}</p>
          </div>
          <button onclick="selectGreeting(${
            index + 1
          })" class="select-button">Select</button>
        </div>`;
          });
        } else {
          greetingsElement.innerHTML = "<p>No greetings found.</p>";
        }
      }

      function selectGreeting(index) {
        const greetingElement = document.getElementById(`greeting-${index}`);
        console.log(`Element ID: greeting-${index}`);
        if (greetingElement) {
          const selectedGreeting = greetingElement.innerText
            .replace(/^\d+ - /, "") // Remove the index and hyphen
            .replace(/\s*Select$/, "") // Remove trailing " Select" if present
            .trim();

          const selectedGreetingParam = encodeURIComponent(selectedGreeting);

          const url = generate_url(CharacterData, selectedGreeting);

          if (url) {
            window.location.href = url; // Redirect to the generated URL
          } else {
            console.error("Error generating URL.");
          }
        } else {
          console.error(`Element with ID 'greeting-${index}' not found.`);
        }
      }

      function generate_url(characterData, greeting) {
        // Extracting relevant data from the JSON
        const name = characterData.data.name;
        const roleInstruction = characterData.data.description || "";

        let behavior = characterData.data.description || "";
        if (characterData.data.description && characterData.data.personality) {
          behavior += "\n\n" + characterData.data.personality;
        } else if (
          !characterData.data.description &&
          characterData.data.personality
        ) {
          behavior = characterData.data.personality;
        }

        const speech = greeting || characterData.data.first_mes;
        const systemPrompt = characterData.data.system_prompt || "";
        const postHistoryInstructions =
          characterData.data.post_history_instructions || "";

        // Choose reminderMessage based on the conditions
        const reminderMessage = systemPrompt || postHistoryInstructions || "";

        // Constructing the character object
        const characterObject = {
          addCharacter: {
            name: name,
            roleInstruction: roleInstruction,
            behavior: behavior,
            speech: speech,
            reminderMessage: reminderMessage,
            modelName: "good",
            maxTokensPerMessage: null,
            fitMessagesInContextMethod: "summarizeOld",
            textEmbeddingModelName: "text-embedding-ada-002",
            autoGenerateMemories: "v1",
            temperature: 0.85,
            customCode: "",
            initialMessages: [
              { content: speech, author: "ai", hiddenFrom: [] },
            ],
            avatar: Avatar,
            scene: {
              background: { url: "" },
              music: { url: "" },
            },
            userCharacter: { avatar: {} },
            systemCharacter: { avatar: {} },
            streamingResponse: true,
            folderPath: "",
            customData: {},
            uuid: null,
            folderName: "",
          },
        };

        // Convert the character object to a JSON string
        const characterJson = JSON.stringify(characterObject);

        // URL encode the JSON string
        const urlEncodedJson = encodeURIComponent(characterJson);

        const finalUrl = `https://ttalesinteractive.com/beta/oai/play.html#${urlEncodedJson}`;

        return finalUrl;
      }

      function toggleFloatingWindow() {
        const floatingWindow = document.getElementById("floating-window");
        const isVisible =
          window.getComputedStyle(floatingWindow).display !== "none";

        if (isVisible) {
          floatingWindow.style.display = "none";
        } else {
          floatingWindow.style.display = "block";
        }
      }

      updateAddCharacterButtonVisibility(); // Call the function initially
    </script>

    <script>
      class Png {
        // Parse and extract PNG tEXt chunk
        static #decodeText(data) {
          let naming = true;
          let keyword = "";
          let text = "";

          for (let index = 0; index < data.length; index++) {
            const code = data[index];

            if (naming) {
              if (code) {
                keyword += String.fromCharCode(code);
              } else {
                naming = false;
              }
            } else {
              if (code) {
                text += String.fromCharCode(code);
              } else {
                throw new PngDecodeError(
                  "Invalid NULL character found in PNG tEXt chunk"
                );
              }
            }
          }

          return {
            keyword,
            text,
          };
        }

        // Read PNG format chunk
        static #readChunk(data, idx) {
          // Read length field
          const uint8 = new Uint8Array(4);
          const uint32 = new Uint32Array(uint8.buffer);
          uint8[3] = data[idx++];
          uint8[2] = data[idx++];
          uint8[1] = data[idx++];
          uint8[0] = data[idx++];
          const length = uint32[0];

          // Read chunk type field
          const chunkType =
            String.fromCharCode(data[idx++]) +
            String.fromCharCode(data[idx++]) +
            String.fromCharCode(data[idx++]) +
            String.fromCharCode(data[idx++]);

          // Read chunk data field
          const chunkData = data.slice(idx, idx + length);
          idx += length;

          // Read CRC field
          uint8[3] = data[idx++];
          uint8[2] = data[idx++];
          uint8[1] = data[idx++];
          uint8[0] = data[idx++];
          const crc = new Int32Array(uint8.buffer)[0];

          // Compare stored CRC to actual
          if (crc !== CRC32.buf(chunkData, CRC32.str(chunkType)))
            throw new PngDecodeError(
              'CRC for "' +
                chunkType +
                '" header is invalid, file is likely corrupted'
            );

          return {
            type: chunkType,
            data: chunkData,
            crc,
          };
        }

        // Read PNG file and extract chunks
        static #readChunks(data) {
          if (
            data[0] !== 0x89 ||
            data[1] !== 0x50 ||
            data[2] !== 0x4e ||
            data[3] !== 0x47 ||
            data[4] !== 0x0d ||
            data[5] !== 0x0a ||
            data[6] !== 0x1a ||
            data[7] !== 0x0a
          )
            throw new PngFormatError("Invalid PNG header");

          const chunks = [];

          let idx = 8; // Skip signature
          while (idx < data.length) {
            const chunk = Png.#readChunk(data, idx);

            if (!chunks.length && chunk.type !== "IHDR")
              throw new PngDecodeError("PNG missing IHDR header");

            chunks.push(chunk);
            idx += 4 + 4 + chunk.data.length + 4; // Skip length, chunk type, chunk data, CRC
          }

          if (chunks.length === 0)
            throw new PngDecodeError("PNG ended prematurely, no chunks");
          if (chunks[chunks.length - 1].type !== "IEND")
            throw new PngDecodeError(
              "PNG ended prematurely, missing IEND header"
            );

          return chunks;
        }

        // Parse PNG file and return decoded UTF8 "chara" base64 tEXt chunk value
        static Parse(arrayBuffer) {
          const chunks = Png.#readChunks(new Uint8Array(arrayBuffer));

          const text = chunks
            .filter((c) => c.type === "tEXt")
            .map((c) => Png.#decodeText(c.data));
          if (text.length < 1)
            throw new PngMissingCharacterError(
              "No PNG text fields found in file"
            );

          const chara = text.find((t) => t.keyword === "chara");
          if (chara === undefined)
            throw new PngMissingCharacterError(
              'No PNG text field named "chara" found in file'
            );

          try {
            return new TextDecoder().decode(
              Uint8Array.from(atob(chara.text), (c) => c.charCodeAt(0))
            );
          } catch (e) {
            throw new PngInvalidCharacterError(
              'Unable to parse "chara" field as base64',
              {
                cause: e,
              }
            );
          }
        }
      }

      // Function to extract character data from a PNG file
      function extractCharacterData(pngFile) {
        return new Promise((resolve, reject) => {
          const fileReader = new FileReader();
          fileReader.readAsArrayBuffer(pngFile);

          fileReader.onload = function () {
            try {
              const characterDataJson = Png.Parse(fileReader.result);
              const characterData = JSON.parse(characterDataJson);
              resolve(characterData);
            } catch (error) {
              reject(error);
            }
          };
        });
      }
    </script>
  </body>
</html>
